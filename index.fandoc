**************************************************************************
** title:      Haystack Java Toolkit
** author:     Brian Frank
** created:    11 Nov 10
** copyright:   Copyright (c) 2011, SkyFoundry, LLC
**************************************************************************

Overview [#overview]
********************

[Project Haystack]`http://project-haystack.org/` defines a
tagging library for modeling building systems such as HVAC, lighting,
and energy equipment.  This toolkit provides a simple, small Java API for
working with haystack tags:

 - **Modeling**: simple APIs for modeling tags and their scalar values.
 - **String Serialization**: encoding and decoding tags using simple plain text format
 - **Query**: simple query language AST and parser
 - **Servlet**: servlet with simple Rest HTTP API to query entities
   by their tags and access historical time-series data

All code is written to work with Java 1.4 and J2ME (no use of newer Java
features such as generics).  This code is all open sourced under the Academic
Free License version 3.0 (same license used as Project Haystack).

Model APIs [#model]
*******************

The API is designed to model tags using the following key classes:

- 'HDict': immutable map of name/value tag pairs
- 'HVal': base class for tag value types
- 'HDictBuilder': builder used to construct an HDict instance

The 'HVal' subclasses for each of the haystack tag types:

 - 'HMarker': singleton value for marker tag
 - 'HBool': true/false boolean values
 - 'HNum': number as 64-bit double with optional unit name
 - 'HStr': wraps java.lang.String
 - 'HUri': models a URI as a string value
 - 'HRef': reference with identifier string and optional display string
 - 'HDate': date as year, month, day
 - 'HTime': time as hour, minute, second, milliseconds
 - 'HDateTime': date time with timezone offset and timezone name

The 'HDict' and 'HVal' classes are immutable, once an instance is
constructed it cannot be modified.  The 'HDictBuilder' class is used
to build an immutable 'HDict' instance:

  // using builder API
  HDict tags = new HDictBuilder()
                     .add("dis", "Building A")
                     .add("area", 13500)
                     .add("built", HDate.make(1970,6,3))
                     .add("site")
                     .toDict();

  // if performance isn't critical, just use string
  HDict tags = HDict.read("dis:\"Building A\", area:13500, built: 1970-06-03, site");

Once an instance is created, you can query for the tags using the
'HDict.get' method or iterate with 'HDict.iterator' method:

  tags.get("dis")     // evalutes to HStr("Building A")
  tags.get("site")    // evaluates to HMarker.VAL
  tags.has("site")    // evaluates to true

  // iterate all the name/value pairs
  for (Iterator it = tags.iterator(); it.hasNext(); )
  {
    Map.Entry e = (Map.Entry)it.next();
    String name = (String)e.getKey();
    HVal val    = (HVal)e.getValue();
  }

Plaintext Format [#format]
**************************
The toolkit supports a simple plaintext format for serializing and
deserializing tags to/from string.  This format is designed to be
easy to read/write by humans but is also extremely efficient for
serializing tags between machines.

The basic format follows these rules:

- Encode each entity's tags on a single line separated by newline "\n" character
- Encode tags as comma separated list of "name:val" pairs
- Marker value is encoded as "name" omitting ":val"
- Bool value is encoded as "true" or "false"
- Num value is encoded as Java-styled floating point number with optional
  [unit name]`http://project-haystack.org/doc/Units`
- Str value is encoded as string literal using Java-styled backslash escapes
- Uri value is encoded with '`' backticks
- Ref value is encoded inside "@xxxx" followed by optional display name as string literal
- Date value is encoded in ISO 8601 as "YYYY-MM-DD"
- Time value is encoded in ISO 8601 as "hh:mm:ss[.FFF]"
- DateTime value is encoded in ISO 8601 as "YYYY-MM-DD'T'hh:mm:ss[.FFF]zz tz"
  where "tz" is a standard [timezone name]`http://project-haystack.org/doc/TimeZones`
- Must always use UTF-8 for input/output

Here are some simple examples:

  id:@site-a, dis:"Site-A", site, built: 1970-06-03, occStart: 09:30:00
  dis:"Site-A RTU-1", ahu, equip, siteRef:@site-a "Site A"
  dis:"Damper", point, val:10%, lastRead:2011-06-08T17:07:34-04:00 New_York

Formal BNF grammer of the string encoding:

  // tags
  <tags>        := <tag> (<sp> "," <sp> <tag>)*
  <tag>         := <name> [":" <val>]
  <val>         := <bool> | <num> | <str> | <uri> | <ref> | <bin> | <date> | <time> | <dateTime>
  <sp>          := 0x20 space

  // name identifiers
  <name>        :=  <alphaLo> (<alphaLo> | <alphaHi> | <digit> | '_')*
  <alphaLo>     := ('a' - 'z')
  <alphaHi>     := ('A' - 'Z')
  <digit>       := ('0' - '9')
  <digits>      := <digit> (<digit> | "_")*

  // bool value
  <bool>        := "true" | "false"

  // num value
  <number>      := <decimal> | "INF" | "-INF" | "NaN"
  <decimal>     := ["-"] <digits> ["." <digits>] [<exp>] [<unit>]
  <exp>         := ("e"|"E") ["+"|"-"] <digits>
  <unit>        := <unitChar>*
  <unitChar>    := <alpha> | "%" | "_" | "/" | "$" | any char > 128

  // str value
  <str>         := '"' <strChar>* '"'
  <strChar>     := <unicodeChar> | <escapeChar>
  <unicodeChar> := any 16-bit Unicode char >= 0x20 and not "$"
  <escapeChar>  := "\b" | "\f" | "\n" | "\r" | "\r" | "\t" | "\"" |
                   "\$" | "\'" | "\`" | "\\" |
                   "\u" <hexDigit> <hexDigit> <hexDigit> <hexDigit>
  <hexDigit>    := ('a'-'f') | ('A'-'F') | <digit>

  // uri value
  <uri>         := '`' <uriChar>* '`'
  <uriChar>     := any ASCII char between 0x20 and 0x7f except "`" 0x60

  // ref value
  <ref>         := "@" <refChar>* [ " " <str> ]
  <refChar>     := <alpha> | <digit> | "_" | ":" | "-" | "."

  // binary
  <bin>         := "Bin(" <binChar>* ")"
  <binChar>     := any char between 0x20 and 0x7F except ")"

  // date/time values
  <date>        := YYYY-MM-DD
  <time>        := hh:mm:ss[.FFF]
  <dateTime>    := YYYY-MM-DD'T'h:mm:ss[.FFF]zz tz

Query Language [#query]
***********************
The toolkit includes a simple tag based query modeled by the 'HQuery' class.
You can parse a query using 'read' and use 'include' to check if a 'HDict'
instance matches the query:

  HQuery query = HQuery.read("site and area > 15000");
  boolean match = query.include(db, rec);

The simple usage is just a tag name which matches any record that
has the tag (regardless of its value):

  site  // query any record with the "site" tag

To match a tag value you can use any of the equality or comparison
operators:

  geoPostalCode == "23220"   // equal to
  geoPostalCode != "23220"   // not equal to
  temp < 75                  // less than
  temp <= 75                 // less than or equal to
  temp > 75                  // greater than
  temp >= 75                 // greater than or equal to

Compare operators can use all the standard scalar from the [plain text]`#format`
format.

You can combine filters using 'and', 'or', or 'not':

  site or equip             // has site or equip tag
  equip and hvac            // has equip and hvac tag
  equip and not ahu         // has equip tag, but not the ahu tag

You use the '->' to dereference a tag which has a Ref value.  For
example if your 'equip' rec has a 'siteRef' tag that references the
site, you can query for equip in a given city such as:

  equip and siteRef->geoCity == "Chicago"

The way to read the above expression is match a record if:
  - it has equip tag
  - and it has a siteRef tag which is a Ref
  - and what the siteRef tag points to has the geoCity tag
  - and that the site's geoCity tag is equal to "Chicago"

The formal grammar of the query langauge:
   <query>      :=  <predicate>
   <predicate>  :=  <condOr>
   <condOr>     :=  <condAnd> ("or" <condAnd>)*
   <condAnd>    :=  <term> ("and" <term>)*
   <term>       :=  <parens> | <has> | <missing> | <cmp>
   <parens>     :=  "(" <predicate> ")"
   <has>        :=  <path>
   <missing>    :=  "not" <path>
   <cmp>        :=  <path> <cmpOp> <val>
   <cmpOp>      :=  "=" | "!=" | "<" | "<=" | ">" | ">="
   <path>       :=  <name> ("->" <name>)*
   <val>        :=  same as plain text format

Rest API [#rest]
****************
The 'HServlet' class provides a Java Servlet that can be used to expose
Haystack tagged data over a simple HTTP API.  The following URIs
are published:

  GET  {haystack}/about
  GET  {haystack}/query?{query}
  POST {haystack}/query
  GET  {haystack}/his/{id}?{range}

For all URIs you can pass the query string as part of the URI query
after the '?', but it must be correctly encoded.  Or you can use a POST
request and pass the query as the request content.

Rest About [#restAbout]
=======================
Return server meta which includes:

  haystackVersion: "1.0"
  serverName: Str
  serverBootTime: DateTime
  serverTime: DateTime
  productName: Str
  productVersion: Str
  productUri: Uri
  moduleName: Str
  moduleVersion: Str
  moduleUri: Str
  tz: Str

Rest Query [#restQuery]
=======================
A query request takes a tag query in the query string or as the POST
content which.  The query string must adhere to [HQuery grammar]`#query`.
Any matching entities in the server are returned in plain text as
encoded tags.  Every entity must have an 'id' tag.

Error conditions:
  - 400: if query is not valid query format

Rest His [#restHis]
====================
A his request takes an entity id and a date range and returns history
items as ts, val pair encoded tags.  The date range should match
the syntax supported by 'HDateTimeRange':
 - "today"
 - "yesterday"
 - "{date}"
 - "{date},{date}"
 - "{dateTime},{dateTime}"
 - "{dateTime}"  // anything after given timestamp

Date based ranges are always inferred to be from midnight of starting date
to midnight of the day after ending date using the timezone of the his entity
being queried.

Error conditions:
  - 404: if id does not map to known entity
  - 404: if entity does implement the 'his' tag
  - 404: if entity does define a valid 'tz' tag
  - 400: if date range is not properly formatted


